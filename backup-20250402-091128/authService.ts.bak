/**
 * Auth Service
 * 
 * This service handles authentication, token management, and user session.
 * It provides methods for login, logout, token refresh, and user data access.
 * Implements secure authentication practices including HttpOnly cookies,
 * token rotation, and protection against common security vulnerabilities.
 */

import { 
  User, 
  LoginCredentials, 
  RegisterCredentials, 
  LoginResponse, 
  AuthResponse,
  AUTH_EVENTS,
  PASSWORD_EVENTS,
  API_EVENTS,
  TokenVerificationResponse,
  AuthError
} from '../types/auth.types';
import { apiClient } from '../../../lib/api/api-client';
import { ApiHealth, ApiStatus } from '../../../lib/api/api-health';

// API endpoints
const AUTH_ENDPOINTS = {
  LOGIN: '/auth/login',
  LOGOUT: '/auth/logout',
  REFRESH: '/auth/refresh-token', // Make sure this matches your backend endpoint
  VERIFY: '/auth/verify',
  REGISTER: '/auth/register',
  CURRENT_USER: '/auth/me',
  SESSION: '/auth/session',
  SET_COOKIE: '/auth/set-cookie',
  CLEAR_COOKIE: '/auth/clear-cookie'
} as const;

// Client-side storage keys 
// Note: These are used only for non-sensitive data
// Auth tokens are stored in HttpOnly cookies for security
const STORAGE_KEYS = {
  USER_DATA: 'user_data',
  AUTH_STATE: 'auth_state',
  TOKEN_EXPIRY: 'token_expiry',
  DEV_MODE_AUTH: 'dev_mode_auth'
};

// Constants for authentication security
const AUTH_CONSTANTS = {
  MAX_LOGIN_ATTEMPTS: 5,
  LOCKOUT_DURATION: 15 * 60 * 1000, // 15 minutes in milliseconds
  PASSWORD_MIN_LENGTH: 8,
  PASSWORD_REQUIRES_SPECIAL_CHARS: true,
  TOKEN_REFRESH_INTERVAL_MS: 14 * 60 * 1000, // Refresh token 1 minute before expiration (assuming 15 min tokens)
  SESSION_TIMEOUT_MS: 12 * 60 * 60 * 1000 // 12 hours
};

// Admin account for development
const DEFAULT_ADMIN_USER: User = {
  id: '1',
  username: 'admin',
  email: 'admin@example.com',
  fullName: 'Admin User',
  roles: ['Admin'],
  createdAt: new Date().toISOString(),
  isActive: true,
  permissions: ['*']
};

// Initialize API health monitoring
const apiHealth = new ApiHealth();

// Store failed login attempts
const loginAttempts = new Map<string, { count: number, timestamp: number }>();

// Flag for development environment
const isDevelopment = import.meta.env.MODE === 'development';

/**
 * Dispatch an authentication event
 * @param eventName Event name
 * @param detail Event details
 */
function dispatchAuthEvent(eventName: string, detail: Record<string, any> = {}): void {
  if (typeof window !== 'undefined') {
    const event = new CustomEvent(eventName, { 
      detail: { 
        timestamp: new Date().toISOString(),
        ...detail
      }
    });
    window.dispatchEvent(event);
    console.log(`[AUTH] Event dispatched: ${eventName}`, detail);
  }
}

/**
 * Helper function to create AuthError with proper params
 * 
 * @param codeOrError Error code, error object, or any other value
 * @param message Optional error message
 * @param details Optional error details
 * @returns AuthError instance
 */
const createAuthError = (
  codeOrError: string | Error | any,
  message?: string,
  details?: any
): AuthError => {
  // If already an AuthError, return it
  if (codeOrError instanceof AuthError) {
    return codeOrError;
  }
  
  // If error object passed
  if (codeOrError instanceof Error) {
    return new AuthError('auth_error', codeOrError.message, { originalError: codeOrError });
  }
  
  // If just a string passed (either code or message)
  if (typeof codeOrError === 'string') {
    return new AuthError(
      message ? codeOrError : 'auth_error', // If message provided, first param is code
      message || codeOrError, // If no message, use first param as message
      details
    );
  }
  
  // Default case for unexpected inputs
  return new AuthError(
    'auth_error',
    'Authentication error occurred',
    codeOrError // Use the input as details
  );
};

/**
 * Authentication Service
 * Provides methods for user authentication and token management
 */
export const authService = {
  /**
   * Initialize the auth service
   * Sets up event listeners and checks token validity
   */
  init(): void {
    console.log('[AUTH] Initializing auth service');
    
    // Check if already initialized to prevent duplicate initialization
    if (localStorage.getItem('auth_initialized') === 'true') {
      console.log('[AUTH] Auth service already initialized');
      return;
    }
    
    // Listen for API status changes using DOM events
    // The ApiHealth class dispatches events through document.dispatchEvent()
    document.addEventListener(API_EVENTS.AVAILABLE as string, ((event: Event) => {
      const customEvent = event as CustomEvent;
      const { current } = customEvent.detail;
      if (current === ApiStatus.AVAILABLE) {
        this.handleApiAvailable();
      }
    }).bind(this));

    document.addEventListener(API_EVENTS.UNAVAILABLE as string, ((event: Event) => {
      console.log('[AUTH] API unavailable event received');
      const customEvent = event as CustomEvent;
      this.dispatchAuthEvent(AUTH_EVENTS.API_UNAVAILABLE, customEvent.detail);
    }).bind(this));
    
    // Set up session timeout
    this.setupSessionTimeout();
    
    // Try to validate existing token
    this.checkTokenValidity()
      .then(isValid => {
        if (isValid) {
          console.log('[AUTH] Token is valid');
          // Load user data from client storage and update
          const userData = this.getCurrentUser();
          if (userData) {
            // Fetch the latest user data from server in the background
            this.fetchCurrentUser().catch(err => {
              console.warn('[AUTH] Failed to fetch current user:', err.message);
            });
            
            dispatchAuthEvent(AUTH_EVENTS.AUTHENTICATED, { user: userData });
          }
          
          // Setup token refresh
          this.setupTokenRefresh();
        } else {
          console.log('[AUTH] Token is not valid');
          // Try to refresh token
          this.refreshToken().catch(() => {
            // Clear auth if refresh fails
            this.clearAuthentication();
          });
        }
        
        // Mark as initialized
        localStorage.setItem('auth_initialized', 'true');
      })
      .catch(error => {
        console.error('[AUTH] Error during initialization:', error);
        localStorage.setItem('auth_initialized', 'true');
      });
  },
  
  /**
   * Handle API becoming available
   */
  handleApiAvailable(): void {
    console.log('[AUTH] API is now available');
    
    // Validate token when API becomes available
    if (this.isAuthenticated()) {
      this.checkTokenValidity().then(isValid => {
        if (!isValid) {
          this.refreshToken().catch(() => {
            this.clearAuthentication();
          });
        }
      });
    }
    
    dispatchAuthEvent(AUTH_EVENTS.API_AVAILABLE);
  },
  
  /**
   * Handle API becoming unavailable
   */
  handleApiUnavailable(): void {
    console.log('[AUTH] API is now unavailable');
    
    // Pause token refresh when API is down
    if (window._tokenRefreshInterval) {
      clearInterval(window._tokenRefreshInterval as number);
      window._tokenRefreshInterval = null;
    }
    
    dispatchAuthEvent(AUTH_EVENTS.API_UNAVAILABLE);
  },
  
  /**
   * Set up session timeout
   * Logs out user after period of inactivity
   */
  setupSessionTimeout(): void {
    if (typeof window === 'undefined') return;
    
    let activityTimeout: number | NodeJS.Timeout | undefined;
    
    // Reset timer on user activity
    const resetTimer = () => {
      if (activityTimeout) {
        window.clearTimeout(activityTimeout as number);
      }
      
      // Only set timeout if user is logged in
      if (this.isAuthenticated()) {
        activityTimeout = window.setTimeout(() => {
          console.log('[AUTH] Session timeout due to inactivity');
          dispatchAuthEvent(AUTH_EVENTS.SESSION_TIMEOUT);
          this.logout();
        }, AUTH_CONSTANTS.SESSION_TIMEOUT_MS);
      }
    };
    
    // Activity events to listen for
    const activityEvents = [
      'mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'
    ];
    
    // Add event listeners
    activityEvents.forEach(event => {
      window.addEventListener(event, resetTimer);
    });
    
    // Initial setup
    resetTimer();
  },
  
  /**
   * Check if the current token is valid
   * @returns True if token is valid, false otherwise
   */
  async checkTokenValidity(): Promise<boolean> {
    try {
      // Check if user data exists in session storage
      const userData = sessionStorage.getItem(STORAGE_KEYS.USER_DATA);
      if (!userData) {
        console.log('[AUTH] No user data in storage');
        return false;
      }
      
      // Check if token has already expired based on client-side timestamp
      const tokenExpiry = localStorage.getItem(STORAGE_KEYS.TOKEN_EXPIRY);
      if (tokenExpiry) {
        const expiryTime = parseInt(tokenExpiry, 10);
        const currentTime = Date.now();
        
        // If token is more than 5 seconds from expiring, consider it valid client-side
        if (expiryTime > currentTime + 5000) {
          console.log('[AUTH] Token not expired based on client timestamp');
          
          // Skip API call if API is not available and we're in development mode
          if (isDevelopment && !apiHealth.isAvailable()) {
            console.log('[AUTH] Development mode: Assuming token is valid');
            this.dispatchAuthEvent(AUTH_EVENTS.TOKEN_REFRESH);
            return true;
          }
        } else {
          console.log('[AUTH] Token expired based on client timestamp');
          this.dispatchAuthEvent(AUTH_EVENTS.TOKEN_EXPIRED);
          return false;
        }
      }
      
      // If API is not available, can't verify token
      if (!apiHealth.isAvailable()) {
        console.log('[AUTH] API not available, cannot verify token');
        return false;
      }
      
      // Call the verify endpoint to check token validity
      console.log('[AUTH] Verifying token with API');
      const response = await apiClient.get<TokenVerificationResponse>(AUTH_ENDPOINTS.VERIFY);
      
      if (response.data?.valid) {
        console.log('[AUTH] Token verified as valid');
        this.dispatchAuthEvent(AUTH_EVENTS.TOKEN_REFRESH);
        return true;
      } else {
        console.log('[AUTH] Token invalid according to API');
        this.dispatchAuthEvent(AUTH_EVENTS.TOKEN_EXPIRED);
        return false;
      }
    } catch (error) {
      console.error('[AUTH] Error checking token validity:', error);
      this.dispatchAuthEvent(AUTH_EVENTS.AUTH_ERROR, { error });
      return false;
    }
  },
  
  /**
   * Set up token refresh interval
   */
  setupTokenRefresh(): void {
    // Clear any existing refresh interval
    if (window._tokenRefreshInterval) {
      clearInterval(window._tokenRefreshInterval);
    }
    
    // Set refresh interval to refresh token before it expires
    const refreshInterval = AUTH_CONSTANTS.TOKEN_REFRESH_INTERVAL_MS;
    
    console.log(`[AUTH] Setting token refresh interval: ${refreshInterval / 1000} seconds`);
    
    window._tokenRefreshInterval = setInterval(async () => {
      try {
        // Skip refresh if API is unavailable
        if (!apiHealth.isAvailable()) {
          console.log('[AUTH] API unavailable, skipping token refresh');
          return;
        }
        
        const refreshed = await this.refreshToken();
        if (refreshed) {
          this.dispatchAuthEvent(AUTH_EVENTS.TOKEN_REFRESH);
        } else {
          this.dispatchAuthEvent(AUTH_EVENTS.TOKEN_EXPIRED);
        }
      } catch (error) {
        console.error('[AUTH] Error refreshing token:', error);
        this.dispatchAuthEvent(AUTH_EVENTS.AUTH_ERROR, { error });
      }
    }, refreshInterval);
  },
  
  /**
   * Refresh authentication token
   * @returns Promise with the refresh result
   */
  async refreshToken(): Promise<AuthSession | null> {
    console.log('[AUTH] Attempting to refresh token');
    
    try {
      // Try to refresh token with API
      const response = await apiClient.post<AuthResponse<AuthSession>>(AUTH_ENDPOINTS.REFRESH, {}, {
        // Use AbortController for timeout
        signal: (() => {
          const controller = new AbortController();
          setTimeout(() => controller.abort(), 5000); // 5 second timeout
          return controller.signal;
        })()
      });
      
      // Update authentication state if successful
      if (response.data) {
        const { tokenExpiry } = response.data;
        
        if (tokenExpiry) {
          console.log(`[AUTH] Token refreshed, expires in ${tokenExpiry} seconds`);
          
          // Update expiry time in storage
          const expiryTime = Date.now() + (tokenExpiry * 1000);
          localStorage.setItem(STORAGE_KEYS.TOKEN_EXPIRY, expiryTime.toString());
          
          // Adjust token refresh interval if needed
          this.setupTokenRefresh();
          
          this.dispatchAuthEvent(AUTH_EVENTS.TOKEN_REFRESH);
          return response.data;
        }
      }
      
      console.warn('[AUTH] Token refresh failed - invalid response');
      this.dispatchAuthEvent(AUTH_EVENTS.TOKEN_EXPIRED);
      return null;
    } catch (error) {
      console.error('[AUTH] Error refreshing token:', error);
      this.dispatchAuthEvent(AUTH_EVENTS.AUTH_ERROR, { error });
      return null;
    }
  },
  
  /**
   * Clear all authentication data
   */
  clearAuthentication(): void {
    console.log('[AUTH] Clearing authentication');
    
    // Clear HttpOnly cookies via backend
    apiClient.post(AUTH_ENDPOINTS.CLEAR_COOKIE).catch(err => {
      console.error('[AUTH] Error clearing auth cookies:', err);
    });
    
    // Clear client-side state
    this.clearClientState();
    
    // Dispatch logout event
    dispatchAuthEvent(AUTH_EVENTS.LOGOUT);
  },
  
  /**
   * Check if user is authenticated
   * @returns True if authenticated, false otherwise
   */
  isAuthenticated(): boolean {
    // Primary check: Check auth state flag
    const authState = localStorage.getItem(STORAGE_KEYS.AUTH_STATE);
    if (authState === 'unauthenticated') return false;
    
    // Secondary check: Check if user data exists
    const userData = localStorage.getItem(STORAGE_KEYS.USER_DATA);
    if (!userData) return false;
    
    return true;
  },
  
  /**
   * Get current user data
   * @returns User data or null if not authenticated
   */
  getCurrentUser(): User | null {
    const userData = localStorage.getItem(STORAGE_KEYS.USER_DATA);
    if (!userData) return null;
    
    try {
      return JSON.parse(userData) as User;
    } catch (error) {
      console.error('[AUTH] Error parsing user data:', error);
      return null;
    }
  },
  
  /**
   * Fetch current user data from server
   * @returns User data
   */
  async fetchCurrentUser(): Promise<User> {
    try {
      const response = await apiClient.get<AuthResponse<User>>(AUTH_ENDPOINTS.CURRENT_USER);
      
      if (response.success && response.data) {
        const user = response.data as unknown as User;
        localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(user));
        return user;
      }
      
      throw new Error(response.message || 'Failed to fetch user data');
    } catch (error: any) {
      throw new AuthError('Failed to fetch user data', error);
    }
  },
  
  /**
   * Check login rate limits
   * @param username Username attempting to log in
   * @returns True if allowed, false if rate limited
   */
  checkLoginRateLimit(username: string): boolean {
    const now = Date.now();
    const userAttempts = loginAttempts.get(username);
    
    if (userAttempts) {
      // Reset counter if lockout period has passed
      if (now - userAttempts.timestamp > AUTH_CONSTANTS.LOCKOUT_DURATION) {
        loginAttempts.set(username, { count: 1, timestamp: now });
        return true;
      }
      
      // Check if user is locked out
      if (userAttempts.count >= AUTH_CONSTANTS.MAX_LOGIN_ATTEMPTS) {
        const remainingTime = Math.ceil((AUTH_CONSTANTS.LOCKOUT_DURATION - 
                              (now - userAttempts.timestamp)) / 60000);
                              
        dispatchAuthEvent(AUTH_EVENTS.LOGIN_RATE_LIMITED, { 
          username, 
          remainingTime 
        });
        
        return false;
      }
      
      // Increment attempt counter
      loginAttempts.set(username, { 
        count: userAttempts.count + 1, 
        timestamp: userAttempts.timestamp 
      });
    } else {
      // First attempt
      loginAttempts.set(username, { count: 1, timestamp: now });
    }
    
    return true;
  },
  
  /**
   * Login user with credentials
   * @param credentials User credentials
   * @returns User data
   */
  async login(credentials: LoginCredentials): Promise<User> {
    try {
      // Check for rate limiting first
      if (!this.checkLoginRateLimit(credentials.username)) {
        throw new AuthError(
          'Too many login attempts. Please try again later.',
          null,
          429
        );
      }
      
      // Check API availability
      const apiAvailable = apiHealth.isAvailable();
      
      // Enhanced development mode checking with more logging
      if (isDevelopment) {
        console.log('[AUTH] Development mode detected');
        console.log('[AUTH] API available:', apiAvailable);
        
        // Force development fallback in dev mode if:
        // 1. API is unavailable OR
        // 2. User has explicitly requested dev mode via localStorage
        const forceDevMode = localStorage.getItem('force_dev_mode') === 'true';
        
        if (!apiAvailable || forceDevMode) {
          console.log('[AUTH] Using development fallback for login');
          console.log('[AUTH] Credentials:', credentials.username);
          
          // Enhanced development login:
          // 1. username=password
          // 2. admin/admin
          // 3. cashier/cashier
          // 4. manager/manager
          if (
            (credentials.username === credentials.password) || 
            (credentials.username === 'admin' && credentials.password === 'admin') ||
            (credentials.username === 'cashier' && credentials.password === 'cashier') ||
            (credentials.username === 'manager' && credentials.password === 'manager')
          ) {
            // Determine role based on username for better testing
            let role = 'Admin';
            let permissions: string[] = ['*'];
            
            if (credentials.username === 'cashier') {
              role = 'Cashier';
              permissions = ['sales.view', 'sales.create', 'inventory.view', 'customers.view'];
            } else if (credentials.username === 'manager') {
              role = 'Manager';
              permissions = ['sales.*', 'inventory.*', 'customers.*', 'reports.view'];
            }
            
            // Create development user
            const devUser: User = {
              id: '1',
              username: credentials.username,
              email: `${credentials.username}@example.com`,
              fullName: `${credentials.username.charAt(0).toUpperCase()}${credentials.username.slice(1)} User`,
              roles: [role],
              permissions,
              createdAt: new Date().toISOString(),
              isActive: true
            };
            
            console.log('[AUTH] Created development user:', devUser);
            
            // Store development user
            localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(devUser));
            localStorage.setItem(STORAGE_KEYS.AUTH_STATE, 'authenticated');
            localStorage.setItem(STORAGE_KEYS.DEV_MODE_AUTH, 'true');
            
            // Set mock expiry time (24 hours)
            const expiryTime = Date.now() + (24 * 60 * 60 * 1000);
            localStorage.setItem(STORAGE_KEYS.TOKEN_EXPIRY, expiryTime.toString());
            
            // Set up token refresh
            this.setupTokenRefresh();
            
            // Dispatch event
            dispatchAuthEvent(AUTH_EVENTS.LOGIN_SUCCESS, { user: devUser });
            
            console.log('[AUTH] Login successful (development mode)');
            return devUser;
          } else {
            console.log('[AUTH] Development login failed - invalid credentials');
            throw new AuthError('Invalid credentials. In development mode, you can login with username=password or use admin/admin, cashier/cashier, or manager/manager');
          }
        }
      }
      
      // Try to ping the API before making the full request
      try {
        const isApiAvailable = await apiHealth.check() === ApiStatus.AVAILABLE;
        if (!isApiAvailable && isDevelopment) {
          console.log('[AUTH] API check failed, forcing development mode');
          // Store in localStorage to use dev mode in future calls
          localStorage.setItem('force_dev_mode', 'true');
          // Retry login with development mode - recursive call, will hit the dev mode path
          return this.login(credentials);
        }
      } catch (pingError) {
        console.log('[AUTH] API ping error:', pingError);
        if (isDevelopment) {
          console.log('[AUTH] Forcing development mode due to ping error');
          localStorage.setItem('force_dev_mode', 'true');
          return this.login(credentials);
        }
      }
      
      // Regular API login flow for production or when API is available
      console.log('[AUTH] Attempting API login with credentials:', credentials.username);
      const response = await apiClient.post<AuthResponse<LoginResponse>>(
        AUTH_ENDPOINTS.LOGIN,
        credentials
      );
      
      if (response.success && response.data) {
        // Type assertion to help TypeScript understand the nested structure
        const loginData = response.data as unknown as LoginResponse;
        
        if (!loginData.user) {
          throw new AuthError('Login response is missing user data');
        }
        
        // Store user data (non-sensitive)
        localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(loginData.user));
        localStorage.setItem(STORAGE_KEYS.AUTH_STATE, 'authenticated');
        
        // Calculate expiry time
        let expiryTime: number;
        if (loginData.expiresAt) {
          expiryTime = new Date(loginData.expiresAt).getTime();
        } else if (loginData.expiresIn) {
          expiryTime = Date.now() + (loginData.expiresIn * 1000);
        } else {
          expiryTime = Date.now() + (24 * 60 * 60 * 1000); // 24 hours default
        }
        
        localStorage.setItem(STORAGE_KEYS.TOKEN_EXPIRY, expiryTime.toString());
        
        // Set up token refresh
        this.setupTokenRefresh();
        
        // Reset login attempts for this user
        loginAttempts.delete(credentials.username);
        
        dispatchAuthEvent(AUTH_EVENTS.LOGIN_SUCCESS, { user: loginData.user });
        
        return loginData.user;
      }
      
      // Update login attempts
      this.updateLoginAttempts(credentials.username);
      
      // Throw appropriate error
      throw new AuthError(response.message || 'Login failed');
    } catch (error: any) {
      console.error('[AUTH] Login error:', error);
      
      // Handle specific error cases
      let message = 'Login failed. Please check your credentials and try again.';
      let status = error.status || 401;
      
      if (error instanceof AuthError) {
        message = error.message;
        status = error.status || 401;
      } else if (error.response) {
        if (error.response.status === 429) {
          message = 'Too many login attempts. Please try again later.';
          status = 429;
        } else if (error.response.status === 401 || error.response.status === 403) {
          message = 'Invalid username or password';
          status = error.response.status;
          
          // Update login attempts for rate limiting
          this.updateLoginAttempts(credentials.username);
        } else if (error.response.status >= 500) {
          message = 'Server error. Please try again later.';
          status = error.response.status;
        }
      } else if (error.message && error.message.includes('Network Error')) {
        message = 'Cannot connect to server. Please check your internet connection.';
        status = 0;
      }
      
      // Dispatch login failure event
      dispatchAuthEvent(AUTH_EVENTS.LOGIN_FAILURE, { error: message });
      
      throw new AuthError(message, error, status);
    }
  },

  /**
   * Update login attempts for rate limiting
   * @private
   */
  updateLoginAttempts(username: string): void {
    const existing = loginAttempts.get(username);
    
    if (existing) {
      existing.count += 1;
      existing.timestamp = Date.now();
      loginAttempts.set(username, existing);
    } else {
      loginAttempts.set(username, { count: 1, timestamp: Date.now() });
    }
  },
  
  /**
   * Register a new user
   * @param userData User registration data
   * @returns User data
   */
  async register(userData: RegisterCredentials): Promise<User> {
    console.log('[AUTH] Attempting registration');
    
    // Validate password strength
    if (userData.password.length < AUTH_CONSTANTS.PASSWORD_MIN_LENGTH) {
      throw new AuthError(`Password must be at least ${AUTH_CONSTANTS.PASSWORD_MIN_LENGTH} characters long`);
    }
    
    if (AUTH_CONSTANTS.PASSWORD_REQUIRES_SPECIAL_CHARS && 
        !/[!@#$%^&*(),.?":{}|<>]/.test(userData.password)) {
      throw new AuthError('Password must contain at least one special character');
    }
    
    try {
      const response = await apiClient.post<AuthResponse<User>>(AUTH_ENDPOINTS.REGISTER, userData);
      
      if (response.success && response.data) {
        const user = response.data as unknown as User;
        
        // Automatically log in after registration
        await this.login({
          username: userData.username,
          password: userData.password
        });
        
        dispatchAuthEvent(AUTH_EVENTS.REGISTER_SUCCESS, { user });
        
        return user;
      }
      
      throw new Error(response.message || 'Registration failed');
    } catch (error: any) {
      // Handle specific error cases
      let errorMessage = 'Registration failed';
      
      if (error.response) {
        if (error.response.status === 409) {
          errorMessage = 'Username or email already exists';
        } else if (error.response.status === 400) {
          errorMessage = 'Invalid registration data';
        } else if (error.response.status >= 500) {
          errorMessage = 'Server error, please try again later';
        }
        
        // Try to extract error message from response
        if (error.response.data && error.response.data.error) {
          errorMessage = error.response.data.error;
        }
      }
      
      dispatchAuthEvent(AUTH_EVENTS.REGISTER_FAILURE, { error: errorMessage });
      
      throw new AuthError(errorMessage, error);
    }
  },
  
  /**
   * Logout the current user
   */
  async logout(): Promise<void> {
    try {
      if (apiHealth.isAvailable()) {
        // Call server-side logout to invalidate tokens
        await apiClient.post(AUTH_ENDPOINTS.LOGOUT);
        
        // Try to clear HTTP-only cookies
        try {
          await apiClient.post(AUTH_ENDPOINTS.CLEAR_COOKIE);
        } catch (cookieError) {
          console.warn('[AUTH] Failed to clear cookies:', cookieError);
        }
      }
    } catch (error) {
      console.error('[AUTH] Error during logout:', error);
    } finally {
      // Always clear client-side state regardless of API response
      this.clearClientState();
      this.clearAuthentication();
      
      // Clear any auth cookies (best effort approach)
      document.cookie.split(";").forEach(cookie => {
        document.cookie = cookie
          .replace(/^ +/, "")
          .replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);
      });
      
      // Dispatch logout event
      this.dispatchAuthEvent(AUTH_EVENTS.LOGOUT);
    }
  },
  
  /**
   * Clear all client-side authentication state
   * Note: This doesn't clear HttpOnly cookies - that must be done server-side
   */
  clearClientState(): void {
    // Clear session storage
    sessionStorage.removeItem('auth_state');
    sessionStorage.removeItem('last_auth_check');
    sessionStorage.removeItem(STORAGE_KEYS.USER_DATA);
    sessionStorage.removeItem(STORAGE_KEYS.AUTH_STATE);
    sessionStorage.removeItem(STORAGE_KEYS.TOKEN_EXPIRY);
    
    // Clear local storage items
    localStorage.removeItem(STORAGE_KEYS.USER_DATA);
    localStorage.removeItem(STORAGE_KEYS.AUTH_STATE);
    localStorage.removeItem(STORAGE_KEYS.TOKEN_EXPIRY);
    
    // Clear any token refresh interval
    if (typeof window !== 'undefined' && window._tokenRefreshInterval) {
      clearInterval(window._tokenRefreshInterval);
      window._tokenRefreshInterval = null;
    }
  },
  
  /**
   * Validate a password
   * @param password Password to validate
   * @returns Validation result
   */
  validatePassword(password: string): { valid: boolean; message?: string } {
    if (!password || password.length < AUTH_CONSTANTS.PASSWORD_MIN_LENGTH) {
      return { 
        valid: false, 
        message: `Password must be at least ${AUTH_CONSTANTS.PASSWORD_MIN_LENGTH} characters long` 
      };
    }
    
    if (AUTH_CONSTANTS.PASSWORD_REQUIRES_SPECIAL_CHARS && 
        !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
      return { 
        valid: false, 
        message: 'Password must contain at least one special character' 
      };
    }
    
    // Add more password validation rules as needed
    
    return { valid: true };
  },
  
  /**
   * Change user password
   * @param currentPassword Current password
   * @param newPassword New password
   * @returns Success or failure
   */
  async changePassword(currentPassword: string, newPassword: string): Promise<boolean> {
    // Validate new password
    const validation = this.validatePassword(newPassword);
    if (!validation.valid) {
      throw new AuthError(validation.message || 'Invalid password');
    }
    
    try {
      const response = await apiClient.post('/auth/change-password', {
        currentPassword,
        newPassword
      });
      
      if (response.success) {
        dispatchAuthEvent(AUTH_EVENTS.PASSWORD_CHANGED);
        return true;
      }
      
      throw new Error(response.message || 'Failed to change password');
    } catch (error: any) {
      let errorMessage = 'Failed to change password';
      
      if (error.response) {
        if (error.response.status === 401) {
          errorMessage = 'Current password is incorrect';
        } else if (error.response.data && error.response.data.error) {
          errorMessage = error.response.data.error;
        }
      }
      
      throw new AuthError(errorMessage, error);
    }
  },
  
  /**
   * Check if a valid session exists
   * @returns Promise with the user session or null if session is invalid
   */
  async checkSession(): Promise<AuthSession | null> {
    try {
      // Check API health first
      const apiHealth = new ApiHealth(); 
      if (await apiHealth.getStatus() === ApiStatus.UNAVAILABLE) {
        console.log('[AUTH] API unavailable, returning cached session if available');
        // If API is down, try to use cached session
        const cachedSession = this.getCachedSession();
        if (cachedSession) {
          return cachedSession;
        }
        return null;
      }

      const response = await apiClient.get<AuthResponse<AuthSession>>(AUTH_ENDPOINTS.VERIFY);
      if (response.success && response.data) {
        // Cache the session data
        this.cacheSession(response.data);
        return response.data;
      }
      return null;
    } catch (error) {
      console.error('[AUTH] Error checking session:', error);
      // Try to return cached session as fallback
      const cachedSession = this.getCachedSession();
      if (cachedSession) {
        return cachedSession;
      }
      return null;
    }
  },
  
  // Helper method to cache auth session
  cacheSession(session: AuthSession): void {
    if (!session || !session.user) return;
    
    // Store session in localStorage for persistence
    localStorage.setItem('auth_session', JSON.stringify(session));
    // Update last check timestamp
    localStorage.setItem('auth_last_check', Date.now().toString());
  },
  
  // Helper method to get cached session
  getCachedSession(): AuthSession | null {
    try {
      const cachedSession = localStorage.getItem('auth_session');
      if (!cachedSession) return null;
      
      const session = JSON.parse(cachedSession) as AuthSession;
      if (!session || !session.user) return null;
      
      // Check if session is still fresh enough (within 30 minutes)
      const lastCheck = localStorage.getItem('auth_last_check');
      if (lastCheck) {
        const lastCheckTime = parseInt(lastCheck);
        const now = Date.now();
        const MAX_CACHE_AGE = 30 * 60 * 1000; // 30 minutes
        
        if (now - lastCheckTime > MAX_CACHE_AGE) {
          // Session cache is too old
          localStorage.removeItem('auth_session');
          localStorage.removeItem('auth_last_check');
          return null;
        }
      }
      
      return session;
    } catch (error) {
      console.error('[AUTH] Error retrieving cached session:', error);
      return null;
    }
  },

  // Helper to dispatch auth events
  dispatchAuthEvent(eventName: string, detail: Record<string, any> = {}): void {
    if (typeof window !== 'undefined') {
      const event = new CustomEvent(eventName, { 
        detail: { 
          timestamp: new Date().toISOString(),
          ...detail
        }
      });
      window.dispatchEvent(event);
    }
  },

};

// Initialize the auth service
if (typeof window !== 'undefined') {
  if (isDevelopment) {
    // Set up default admin user for development
    localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(DEFAULT_ADMIN_USER));
    localStorage.setItem(STORAGE_KEYS.AUTH_STATE, 'authenticated');
    localStorage.setItem(STORAGE_KEYS.DEV_MODE_AUTH, 'true');
  }
  
  authService.init();
}

// Export isAuthenticated function for easier imports
export const isAuthenticated = () => authService.isAuthenticated();

// Add token refresh interval to Window interface
declare global {
  interface Window {
    _tokenRefreshInterval?: number | NodeJS.Timeout | null;
  }
}

// Auth session interface
export interface AuthSession {
  user: User;
  permissions?: string[];
  sessionId?: string;
  expires?: number;
}
